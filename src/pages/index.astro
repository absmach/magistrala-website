---
import BaseLayout from '../components/layout/BaseLayout.astro';
import Header from '../components/layout/Header.astro';
import Footer from '../components/layout/Footer.astro';
import Hero from '../components/sections/Hero.astro';
import Partners from '../components/sections/Partners.astro';
import Features from '../components/sections/Features.astro';
import WhyMagistrala from '../components/sections/WhyMagistrala.astro';
import Deployments from '../components/sections/Deployments.astro';
import UseCases from '../components/sections/UseCases.astro';
import SuccessStories from '../components/sections/SuccessStories.astro';
import Pricing from '../components/sections/Pricing.astro';
import FAQ from '../components/sections/FAQ.astro';
import CTASection from '../components/sections/CTASection.astro';
---

<BaseLayout>
  <Header />

  <main>
    <Hero />
    <Partners />
    <Features />
    <WhyMagistrala />
    <Deployments />
    <UseCases />
    <SuccessStories />
    <Pricing />
    <FAQ />
    <CTASection />
  </main>

  <Footer />

  <!-- Scroll to top -->
  <button id="scroll-top" class="scroll-top-btn" aria-label="Scroll to top">
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M4.5 15.75l7.5-7.5 7.5 7.5" />
    </svg>
  </button>
</BaseLayout>

<script>
  // SUCCESS_STORIES data is available via server-side import; no global JS data required

  document.addEventListener('DOMContentLoaded', () => {
    // Scroll reveal
    const revealEls = document.querySelectorAll('.reveal');
    
    // [NEW] Apply staggered delays to elements found in groups (like your success stories)
    // This creates the "one-after-another" effect seen in the video.
    revealEls.forEach((el, index) => {
      // We check if the element is part of a list/grid to apply staggering
      const parent = el.parentElement;
      if (parent && (parent.classList.contains('flex') || parent.classList.contains('grid'))) {
         (el as HTMLElement).style.transitionDelay = `${(index % 4) * 150}ms`;
      }
    });

    const revealObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            // [NEW] We keep unobserve to ensure the animation only plays once per scroll-down
            revealObserver.unobserve(entry.target);
          }
        });
      },
      // [NEW] threshold 0.1 is good; rootMargin can be added to trigger slightly before it hits the view
      { threshold: 0.1, rootMargin: '0px 0px -50px 0px' } 
    );
    revealEls.forEach((el) => revealObserver.observe(el));

    // Feature carousels (auto-advancing with progress bar)
    document.querySelectorAll('[data-feature-carousel]').forEach((carousel) => {
      const track = carousel.querySelector('.feature-carousel-track') as HTMLElement;
      const dots = carousel.querySelectorAll('.carousel-dot');
      const progressBar = carousel.querySelector('.carousel-progress-bar') as HTMLElement;
      const slideCount = track ? track.children.length : 0;
      if (!track || slideCount <= 1) return;

      let current = 0;
      let autoInterval: ReturnType<typeof setInterval> | null = null;
      let progressStart = 0;
      let progressRaf: number | null = null;
      const delay = parseInt(carousel.getAttribute('data-auto') || '4000');

      function goTo(index: number) {
        current = index;
        track.style.transform = `translateX(-${current * 100}%)`;
        dots.forEach((d) => d.classList.remove('active'));
        dots[current]?.classList.add('active');
        resetProgress();
      }

      function next() {
        goTo((current + 1) % slideCount);
      }

      function resetProgress() {
        progressStart = performance.now();
        if (!progressRaf) tickProgress();
      }

      function tickProgress() {
        if (!progressBar) return;
        const elapsed = performance.now() - progressStart;
        const pct = Math.min((elapsed / delay) * 100, 100);
        progressBar.style.width = `${pct}%`;
        if (pct < 100) {
          progressRaf = requestAnimationFrame(tickProgress);
        } else {
          progressRaf = null;
        }
      }

      function startAuto() {
        stopAuto();
        resetProgress();
        autoInterval = setInterval(next, delay);
      }

      function stopAuto() {
        if (autoInterval) { clearInterval(autoInterval); autoInterval = null; }
        if (progressRaf) { cancelAnimationFrame(progressRaf); progressRaf = null; }
        if (progressBar) progressBar.style.width = '0%';
      }

      // Dot clicks
      dots.forEach((dot) => {
        dot.addEventListener('click', () => {
          goTo(parseInt(dot.getAttribute('data-slide') || '0'));
          startAuto();
        });
      });

      // Pause on hover
      carousel.addEventListener('mouseenter', stopAuto);
      carousel.addEventListener('mouseleave', startAuto);

      // Start
      startAuto();
    });

    // Use-case carousel (looping, auto-advance)
    const ucEl = document.querySelector('[data-uc-carousel]');
    if (ucEl) {
      const track = ucEl.querySelector('.uc-carousel-track') as HTMLElement;
      const dots = ucEl.querySelectorAll('.uc-dot');
      const prevBtn = ucEl.querySelector('.uc-prev');
      const nextBtn = ucEl.querySelector('.uc-next');
      const slideCount = track ? track.children.length : 0;
      if (track && slideCount > 0) {
        let current = 0;
        let autoTimer: ReturnType<typeof setInterval> | null = null;
        const AUTO_DELAY = 6000;

        function goTo(i: number) {
          current = ((i % slideCount) + slideCount) % slideCount;
          track.style.transform = `translateX(-${current * 100}%)`;
          dots.forEach((d) => d.classList.remove('active'));
          dots[current]?.classList.add('active');
        }

        function startAuto() {
          stopAuto();
          autoTimer = setInterval(() => goTo(current + 1), AUTO_DELAY);
        }

        function stopAuto() {
          if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
        }

        prevBtn?.addEventListener('click', () => { goTo(current - 1); startAuto(); });
        nextBtn?.addEventListener('click', () => { goTo(current + 1); startAuto(); });
        dots.forEach((dot) => {
          dot.addEventListener('click', () => {
            goTo(parseInt(dot.getAttribute('data-slide') || '0'));
            startAuto();
          });
        });

        ucEl.addEventListener('mouseenter', stopAuto);
        ucEl.addEventListener('mouseleave', startAuto);

        goTo(0);
        startAuto();
      }
    }

    // Scroll to top
    const scrollBtn = document.getElementById('scroll-top');
    if (scrollBtn) {
      window.addEventListener('scroll', () => {
        scrollBtn.classList.toggle('visible', window.scrollY > 600);
      });
      scrollBtn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
    }
  });
</script>

<style>
  /* [NEW] Updated transition to match the smooth movement in the video */
  .reveal {
    opacity: 0;
    transform: translateY(2rem);
    transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1), 
                transform 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    will-change: transform, opacity;
  }

  .reveal.visible {
    opacity: 1;
    transform: translateY(0);
  }
</style>
